clear
clc

%% Initiallization
N=10; % Number of nodes in x or y direction
h=2*pi/(N-1); % step size
x=linspace(-pi-h,pi,N+1);
y=linspace(pi,-pi,N);
u_domain=zeros(N,N+1); % domain has additional nodes in x to use later as ghost nodes
[X,Y]=meshgrid(x,y); % x,y grid for plotting
addon=0.4;
cycles=[];
percent_error=[];

%% Domain Boundary Conditions
% Top B.C.'s
f=x(2:end).*(x(2:end)+pi).^2;
u_domain(1,2:end)=f;

% Bottom B.C.'s
g=(x(2:end)+pi).^2.*cos(-x(2:end));
u_domain(N,2:end)=g;

% Right B.C.'s
r=g(end)+((y+pi)/(2*pi))*(f(end)-g(end));
u_domain(:,N+1)=r';

clear r g f

%% Forcing Function
for k=1:length(y)
    for j=1:length(x)
        Force(k,j)=(sin(pi*(x(j)+pi)/(2*pi))*cos((pi/2)*(2*(y(k)+pi)/(2*pi)+1)));
    end
end

%% Gauss Seidel Method
finished=0; % tells the while loop when to stop
while finished<=1
    lambda=1;
    
    
    while lambda<=1+addon
        
        u=u_domain; % Sets or resets the domain boundary conditions and zeros out all others
        errorval=100; %  arbitrary initial error value
        iterations=0; % number of iterations for each solution, later stored as an element in the array "cycles"

        % The while loop below continually improves the solution by using
        % the newly solved values of the domain to solve the domain again,
        % until the error between iterations is less than 1 percent
         
        while errorval>1
            iterations=iterations+1;
            
            u_old=u; % This value is used to calculate error from iteration to iteration
            
            % The while loop below solves the values in the domain by starting at
            % the outermost unknowns near the direchlet boundary conditions and
            % working towards the center of the domain, utilizing as many solved
            % values as possible to reduce the necessary number of iterations.
            counter=2;
            while counter<=N/2
                
                % Top Pyramid
                for j=      N-counter+2   :  -1 :   counter+1
                    u( counter , j ) = (Force(counter,j)*h^2+...
                        u(counter-1,j)+u(counter+1,j)+u(counter,j-1)+u(counter,j+1))*0.25;
                end
                
                % Bottom Pyramid
                for j=      N-counter+2  :  -1 :    counter+1
                    u( N-counter+1 , j ) = (Force(N-counter+1,j) *h^2+...
                        u(N-counter+2,j)+u(N-counter,j)+u(N-counter+1,j-1)+u(N-counter+1,j+1))*0.25;
                end
                
                % Right Pyramid
                for k=       counter+1      :        N-counter
                    u( k , N-counter+2 ) = (Force(k,N-counter+2)*h^2+...
                        u(k-1,N-counter+2)+u(k+1,N-counter+2)+u(k,N-counter+1)+u(k,N-counter+3))*0.25;
                end
                
                counter=counter+1;
            end
            
            % Left Pyramid
            counter2=0;
            if mod(N,2)==0 % even number of nodes
                for j=       floor(N/2)+1 :   -1 :  3
                    counter2=counter2+1;
                    for k =  floor(N/2)-counter2+2    :    floor(N/2)+counter2-1
                        u( k , j) = (Force(k,j)*h^2+...
                            u(k-1,j)+u(k+1,j)+u(k,j-1)+u(k,j+1))*0.25;
                    end
                    
                end
                
            else % odd number of nodes
                for j=       floor(N/2)+2 :   -1 :  3
                    counter2=counter2+1;
                    for k =  floor(N/2)-counter2+2   :    floor(N/2)+counter2
                        u( k , j) = (Force(k,j)*h^2+...
                            u(k-1,j)+u(k+1,j)+u(k,j-1)+u(k,j+1))*0.25;
                    end
                    
                end
            end
            
            % ghost nodes; this code duplicates values from the right side of the
            % Nuemann boundary to the left side, in order to simulate the du/dx=0
            % condition
            u(:,1)=u(:,3);
            
            % left boundary nodes
            for k=2:N-1
                u(k,2)=(Force(k,2)*h^2+...
                    u(k-1,2)+u(k+1,2)+u(k,1)+u(k,3))*0.25;
            end
            
            % remaining 2 nodes at nueman boundary
            u(1,2)=(Force(1,2)*h^2+...
                u(2,2)+u(1,1)+u(1,3))*0.25;
            u(N,2)=(Force(N,2)*h^2+...
                u(N-1,2)+u(N,1)+u(N,3))*0.25;
            
            for k=1:N
                for j=1:N+1
                    if u(k,j) ~= 0
                        error(k,j)=abs((u(k,j)-u_old(k,j))/u(k,j))*100;
                    end
                end
            end
            % average error over domain
            errorval=mean(mean(error));
        end
        cycles(end+1)=iterations;
        percent_error(end+1)=errorval;
        
        lambda=lambda+addon;
    end
    lambda=1;
    Force=Force*0;
    finished=finished+1;
end
figure(1)
mesh(X,Y,u),xlabel('x'),ylabel('y'),zlabel('u'),title('Gauss Seidel Method')
clear error


iterations_relaxed
errorval_relaxed
figure(2)
mesh(X,Y,u_relaxed),xlabel('x'),ylabel('y'),zlabel('u'),title('Gauss Seidel with Relaxation')
clear error

figure(3)
mesh(X,Y,uNoF),xlabel('x'),ylabel('y'),zlabel('u'),title('Gauss Seidel with no Forcing Function')

clear u_old u_old2 u_oldNoF u_domain counter counter2 j k error_no_force x y
